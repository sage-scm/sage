#!/usr/bin/env bash
set -euo pipefail

YELLOW='\033[1;33m'
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

if [ "${SKIP_SAGE_HOOKS:-0}" = "1" ] || [ "${SKIP_PRECOMMIT:-0}" = "1" ]; then
    echo -e "${YELLOW}Skipping pre-commit hook (explicitly disabled)${NC}"
    exit 0
fi

CLIPPY_MODE="${SAGE_HOOKS_CLIPPY:-warn}"
case "$CLIPPY_MODE" in
    skip|warn|enforce) ;;
    *)
        CLIPPY_MODE="warn"
        ;;
esac

AUTOFIX_MODE="${SAGE_HOOKS_AUTOFIX:-on}"
case "$AUTOFIX_MODE" in
    on|off) ;;
    *)
        AUTOFIX_MODE="on"
        ;;
esac

ORIGINAL_STAGED_FILES=()
while IFS= read -r -d '' file; do
    ORIGINAL_STAGED_FILES+=("$file")
done < <(git diff --cached --name-only --diff-filter=ACMR -z)

UNSTAGED_FILES=()
while IFS= read -r -d '' file; do
    UNSTAGED_FILES+=("$file")
done < <(git diff --name-only --diff-filter=ACMR -z)

FILES_TO_RESTAGE=()
PARTIALLY_STAGED_FILES=()

is_unstaged_file() {
    local needle="$1"
    for unstaged in "${UNSTAGED_FILES[@]+"${UNSTAGED_FILES[@]}"}"; do
        if [ "$unstaged" = "$needle" ]; then
            return 0
        fi
    done
    return 1
}

if [ ${#ORIGINAL_STAGED_FILES[@]} -gt 0 ]; then
    for file in "${ORIGINAL_STAGED_FILES[@]}"; do
        if is_unstaged_file "$file"; then
            PARTIALLY_STAGED_FILES+=("$file")
        else
            FILES_TO_RESTAGE+=("$file")
        fi
    done
fi

PARTIALLY_STAGED_COUNT=${#PARTIALLY_STAGED_FILES[@]}
if [ $PARTIALLY_STAGED_COUNT -gt 0 ]; then
    echo -e "${YELLOW}Partial staging detected; preserving staged hunks for:${NC}"
    for file in "${PARTIALLY_STAGED_FILES[@]}"; do
        echo "   $file"
    done
    echo -e "${YELLOW}Skipping auto-format and cargo fix for the files above.${NC}"
fi

restage_original_files() {
    if [ ${#FILES_TO_RESTAGE[@]} -eq 0 ]; then
        return
    fi

    local files_to_stage=()
    for file in "${FILES_TO_RESTAGE[@]}"; do
        if [ -e "$file" ] || [ -L "$file" ]; then
            if [ ${#files_to_stage[@]} -eq 0 ]; then
                files_to_stage=("$file")
            else
                files_to_stage=("${files_to_stage[@]}" "$file")
            fi
        fi
    done

    if [ ${#files_to_stage[@]} -eq 0 ]; then
        return
    fi

    printf '%s\0' "${files_to_stage[@]}" | git add --pathspec-file-nul --pathspec-from-file=-
}

RUST_FILES=()
MANIFEST_PATHS=()

add_manifest_path() {
    local candidate="$1"
    if [ -z "$candidate" ]; then
        return
    fi

    local existing
    if [ ${#MANIFEST_PATHS[@]} -gt 0 ]; then
        for existing in "${MANIFEST_PATHS[@]}"; do
            if [ "$existing" = "$candidate" ]; then
                return
            fi
        done
    fi

    MANIFEST_PATHS+=("$candidate")
}

find_manifest_for_file() {
    local file="$1"
    local dir

    dir=$(dirname "$file")
    while [ "$dir" != "." ] && [ "$dir" != "/" ]; do
        if [ -f "$dir/Cargo.toml" ]; then
            printf '%s\n' "$dir/Cargo.toml"
            return 0
        fi
        dir=$(dirname "$dir")
    done

    if [ -f Cargo.toml ]; then
        printf '%s\n' "Cargo.toml"
        return 0
    fi

    return 1
}

CARGO_LOCK_WAS_STAGED=0
if [ ${#FILES_TO_RESTAGE[@]} -gt 0 ]; then
    for file in "${FILES_TO_RESTAGE[@]}"; do
        case "$file" in
            *.rs)
                if [ ${#RUST_FILES[@]} -eq 0 ]; then
                    RUST_FILES=("$file")
                else
                    RUST_FILES=("${RUST_FILES[@]}" "$file")
                fi
                manifest_path="$(find_manifest_for_file "$file" || true)"
                if [ -n "$manifest_path" ]; then
                    add_manifest_path "$manifest_path"
                fi
                ;;
            Cargo.lock)
                CARGO_LOCK_WAS_STAGED=1
                ;;
        esac
    done
fi

echo -e "${YELLOW}Running pre-commit hooks...${NC}"

# Check if we're in a rebase
if [[ -d ".git/rebase-merge" || -d ".git/rebase-apply" ]]; then
    echo "Skipping hooks during rebase"
    exit 0
fi

# 1. Format staged Rust code only
if [ ${#RUST_FILES[@]} -gt 0 ]; then
    echo -e "${YELLOW}üìù Formatting staged Rust files...${NC}"
    if ! command -v rustfmt >/dev/null 2>&1; then
        echo -e "${RED}‚úó rustfmt is not available; run 'rustup component add rustfmt'${NC}"
        exit 1
    fi

    if rustfmt --edition 2024 "${RUST_FILES[@]}"; then
        echo -e "${GREEN}‚úì Rustfmt completed${NC}"
    else
        echo -e "${RED}‚úó rustfmt failed; ensure your toolchain supports the 2024 edition${NC}"
        echo -e "${YELLOW}  ‚Ä∫ Try 'rustup update' or use 'SKIP_PRECOMMIT=1 git commit' to bypass temporarily${NC}"
        exit 1
    fi

    restage_original_files
else
    if [ $PARTIALLY_STAGED_COUNT -gt 0 ]; then
        echo -e "${YELLOW}Skipping rustfmt to avoid altering partially staged files.${NC}"
    else
        echo -e "${YELLOW}No staged Rust files, skipping formatting.${NC}"
    fi
fi

# 2. Auto-fix common warnings (unused imports, etc.)
if [ ${#RUST_FILES[@]} -gt 0 ] && [ "$AUTOFIX_MODE" = "on" ] && [ $PARTIALLY_STAGED_COUNT -eq 0 ]; then
    if [ ${#MANIFEST_PATHS[@]} -eq 0 ]; then
        echo -e "${YELLOW}No Rust crate manifests detected; skipping cargo fix.${NC}"
    else
        echo -e "${YELLOW}üõ†Ô∏è  Running cargo fix on affected crates...${NC}"
        AUTOFIX_FAILED=0
        for manifest in "${MANIFEST_PATHS[@]}"; do
            manifest_dir=$(dirname "$manifest")
            echo -e "${YELLOW}   ‚Ä∫ cargo fix: ${manifest_dir}${NC}"
            if cargo fix --allow-dirty --allow-staged --all-targets --manifest-path "$manifest" > /dev/null 2>&1; then
                continue
            else
                AUTOFIX_FAILED=1
                echo -e "${RED}‚úó cargo fix failed for ${manifest}${NC}"
                break
            fi
        done

        if [ $AUTOFIX_FAILED -eq 1 ]; then
            echo -e "${YELLOW}  ‚Ä∫ Run 'cargo fix --allow-dirty --allow-staged --all-targets' manually to debug${NC}"
            exit 1
        fi

        restage_original_files
        echo -e "${GREEN}‚úì Auto-fix applied${NC}"
    fi
elif [ ${#RUST_FILES[@]} -gt 0 ] && [ $PARTIALLY_STAGED_COUNT -gt 0 ]; then
    echo -e "${YELLOW}Skipping cargo fix to preserve partially staged files.${NC}"
elif [ "$AUTOFIX_MODE" = "off" ]; then
    echo -e "${YELLOW}Skipping cargo fix (SAGE_HOOKS_AUTOFIX=off).${NC}"
fi

# 3. Advisory clippy run
if [ ${#RUST_FILES[@]} -eq 0 ]; then
    echo -e "${YELLOW}No staged Rust files, skipping clippy.${NC}"
elif [ "$CLIPPY_MODE" = "skip" ]; then
    echo -e "${YELLOW}Skipping clippy (disabled for this repo).${NC}"
else
    echo -e "${YELLOW}üîç Running clippy (mode: $CLIPPY_MODE)...${NC}"
    if cargo clippy --all-targets --all-features -- -D warnings; then
        echo -e "${GREEN}‚úì Clippy checks passed${NC}"
    else
        echo -e "${RED}‚úó Clippy reported issues${NC}"
        echo -e "${YELLOW}  ‚Ä∫ Run 'cargo clippy --all-targets --all-features -- -D warnings' when you're ready to fix them${NC}"
        if [ "$CLIPPY_MODE" = "enforce" ] || [ -n "${CI:-}" ]; then
            exit 1
        fi
    fi
fi

# 4. Check for TODO/FIXME in staged files (optional warning)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(rs|toml)$' || true)
if [ -n "$STAGED_FILES" ]; then
    TODO_MATCHES=$(echo "$STAGED_FILES" | xargs grep -E "(TODO|FIXME|XXX|HACK)" 2>/dev/null || true)
    if [ -n "$TODO_MATCHES" ]; then
        TODO_COUNT=$(printf '%s\n' "$TODO_MATCHES" | grep -c '^')
        echo -e "${YELLOW}‚ö†Ô∏è  Found $TODO_COUNT TODO/FIXME style comments in staged files${NC}"
        printf '%s\n' "$TODO_MATCHES"
        echo -e "${YELLOW}Consider addressing these before committing${NC}"
        # Informational only
    fi
fi

# 5. Ensure Cargo.lock is up to date if Cargo.toml changed
if git diff --cached --name-only | grep -q "Cargo.toml"; then
    echo -e "${YELLOW}üì¶ Validating Cargo.lock...${NC}"
    if ! cargo update --workspace --dry-run > /dev/null 2>&1; then
        echo -e "${RED}‚úó cargo update failed; please resolve dependency issues${NC}"
        exit 1
    fi
    cargo generate-lockfile
    if [ $CARGO_LOCK_WAS_STAGED -eq 1 ]; then
        git add Cargo.lock
        echo -e "${GREEN}‚úì Cargo.lock refreshed and restaged${NC}"
    else
        echo -e "${YELLOW}‚ÑπÔ∏è  Cargo.lock refreshed. Stage it if this change should be committed${NC}"
    fi
fi

echo -e "${GREEN}‚úÖ Pre-commit checks completed${NC}"
